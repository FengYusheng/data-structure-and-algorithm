# Sort
排序就是讲一组对象按照某种逻辑顺序重新排列的过程。在计算时代早期，大家普遍认为30%的计算周期都用在了排序上。如果今天这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了。现在计算机的广泛使用使得数据无处不在，而整理数据的第一步通常是进行排序。

学习排序算法的实际意义：
1. 对排序算法的分析将有助于全面理解本书中比较算法性能的方法
2. 类似的技术也能有效解决其他类型的问题
3. 排序算法常常是我们解决其他问题的第一步

**快速排序**　被誉为20世纪科学和工程领域的十大算法之一。

经典排序算法，优先队列。

## 排序算法的目的
将所有元素的主键按照某种方式排列（通常是按照大小或字母顺序）。排序后*索引*较大的主键大于或等于*索引*较小的主键。

## 排序算法的两个主要操作
1. **比较元素**
2. **交换元素的位置**

## 性能分析
### 排序成本模型
在研究排序算法时，我们需要计算**比较**和**交换**数量。对于不交换元素的算法，我们会计算访问数组的次数。

### 需要考察的操作
1. 比较的次数
2. 交换的次数
3. 如果排序算法不涉及交换操作，就计算访问数组的次数
4. 额外内存的使用情况

### 内存使用情况
1. 无需额外内存的*原地排序算法*
2. 需要额外内存来存*储另一份数组副本*的其他排序算法

### 数据类型
>遵守Java惯例的好处是很多你希望排序的数据都实现了Comparable接口。例如，Java中封装数字的类型Integer和Double，以及String和其他许多高级数据类型（如File和URL）都实现了Comparable接口。因此你可以直接用这些类型的数组作为参数调用我们的排序方法。在创建自己的数据类型时，我们只要实现Comparable接口就能保证用例代码可以将其排序。

### 数据的比较
当两个元素无法比较，比较方法应该抛出异常。比较方法应当实现一个全序关系。
>全序关系: 自反性，对于所有的v，有v=v；反对称性，对于所有的v<w有w>v，且v=w时w=v；传递性，对于所有的v, w和x，如果v<=w且w<=x，则v<=x。

## 选择排序
最简单的排序算法：先找到数组中最小的那个元素，然后将它和数组第一个元素交换位置（如果第一个元素就是最小的，就和自己交换位置）。然后在剩下的元素中找到最小的位置，和第二个元素交换位置。如此往复，直到整个数组排序。*之所以叫这个算法为选择排序，因为它一直在选择数组中最小的那个元素。*

### 性能分析
对于有N个元素的数组，选择排序要进行N次交换和大约N**2/2次比较。选择排序的两个特点：
1. 无论输入数组的初始状态如何理想，该算法的运行时间都是相同的。这是该算法的缺点。
2. *概算法的交换操作次数是最少的，即交换的次数和数组的大小是线性关系*，其他的排序算法都不具备这个特点。

## 插入排序
>人们玩牌时，整理手里牌的方法是一张一张地将牌插入到手中 *已经有序的* 牌中的适当位置。

为了给新插入的元素腾位置，所有元素都要想右移动以为。

### 性能分析
与选择排序不同的是，插入排序所需的时间受输入数组初始状态的影响。对于随机排列的长度为N且 **主键不重复** 的数组，最坏情况下，即数组初始顺序刚好是逆序的，插入排序需要~N**2/2次交换，~N**2/2次比较。最好情况下，即初始数据刚好是有序的，插入排序需要0次交换，N-1次比较。平均情况下插入排序需要~N**2/4次交换，~N**2/4次比较。

### *什么是部分有序？*
如果数组中倒置的的数量小于数组大小的某个倍数，我们就说这个数组是部分有序的。本分有序数组的特点：
1. 数组中每个元素距离它的最终位置都不远。
2. 一个有序的大数组接一个小数组。
3. 数组中只有几个元素位置不正确。

###　*插入排序的性能优势*

插入排序对这样的数组非常有效，选择排序就糟透了。事实上，**当倒置的数量很少时，插入排序比其他排序算法更有效。** 插入排序处理部分有序的数组时，交换操作的次数和倒置的数量相同，比较操作的次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

### 插入排序用途
插入排序对于部分有序的数组非常高效，也很适合小规模数组。部分排序的数组和小规模数组在实际应用中经常出现，插入排序经常是高级排序算法的中间过程。

### Further Reading
1. 提高插入排序速度，见习题2.1.25

## 数据可视化
### 排序算法的可视化
使用　*棒状图*　跟踪排序算法轨迹，能够是排序过程一目了然。

## 比较两种排序算法的快慢
### 比较两种算法的步骤
1. 实现并调试它们；
2. 分析它们的基本性质；
3. 对它们的相对性能做出猜想；
4. 用实验验证我们的猜想。

> 这些简介的步骤之下是大量的算法实现，调试分析和测试工作。每个程序员都知道只有经过长期的调试和改进才能得到这样的代码，每个数学家都知道正确分析的难度，每个科学家也都知道从提出猜想到设计并执行实验来验证它们是多么费心。只有研究那些最重要的算法的专家才会经理这个完整的研究过程，但每个使用算法的程序员都应该了解算法的性能特性背后的科学过程。

**对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别，两者之比应该是一个比较小的常数。**

### 基础排序算法的重要性
1. 它们帮助我们建立了一些基本的规则；
2. 它们展示一些性能基准；
3. 在某些特殊情况下它们也是很好的选择；
4. 它们开发更强大的排序算法的基石。

## 希尔排序
一种基于插入排序的快速的排序算法，*加速版插入排序*。插入排序慢是因为它只交换相邻的元素，也就是说新加入的元素只能一步一步地到达它的最终位置。

## 归并排序
### Top-down mergesort
It is one of the best-known examples of the utility of the *divide-and-conquer* paradigm for efficient 
algorithm design. An inductive proof that the algorithm sorts the array: if it sorts the two subarrays, 
it sorts the whole array, by merging together the subarrays.

The sort code simply provides an organized way to sequence the calls to the `merge()` method. This 
insight is useful.

#### mid index:
* `mid = lo + (hi - lo) / 2`
* `mid = length / 2 - 1`



## TODO:
1. 从标准输入读取数据
2. 数据可视化
3. 打印算法执行过程， 比如 *Top-down mergesort call trace*

# Sort
排序就是讲一组对象按照某种逻辑顺序重新排列的过程。在计算时代早期，大家普遍认为30%的计算周期都用在了排序上。如果今天这个比例降低了，可能的原因之一是如今的排序算法更加高效，而并非排序的重要性降低了。现在计算机的广泛使用使得数据无处不在，而整理数据的第一步通常是进行排序。

学习排序算法的实际意义：
1. 对排序算法的分析将有助于全面理解本书中比较算法性能的方法
2. 类似的技术也能有效解决其他类型的问题
3. 排序算法常常是我们解决其他问题的第一步

**快速排序**　被誉为20世纪科学和工程领域的十大算法之一。

经典排序算法，优先队列。

## 排序算法的目的
将所有元素的主键按照某种方式排列（通常是按照大小或字母顺序）。排序后*索引*较大的主键大于或等于*索引*较小的主键。

## 排序算法的两个主要操作
1. **比较元素**
2. **交换元素的位置**

## 性能分析
### 排序成本模型
在研究排序算法时，我们需要计算**比较**和**交换**数量。对于不交换元素的算法，我们会计算访问数组的次数。

### 需要考察的操作
1. 比较的次数
2. 交换的次数
3. 如果排序算法不涉及交换操作，就计算访问数组的次数
4. 额外内存的使用情况

### 内存使用情况
1. 无需额外内存的*原地排序算法*
2. 需要额外内存来存*储另一份数组副本*的其他排序算法

### 数据类型
>遵守Java惯例的好处是很多你希望排序的数据都实现了Comparable接口。例如，Java中封装数字的类型Integer和Double，以及String和其他许多高级数据类型（如File和URL）都实现了Comparable接口。因此你可以直接用这些类型的数组作为参数调用我们的排序方法。在创建自己的数据类型时，我们只要实现Comparable接口就能保证用例代码可以将其排序。

### 数据的比较
当两个元素无法比较，比较方法应该抛出异常。比较方法应当实现一个全序关系。
>全序关系: 自反性，对于所有的v，有v=v；反对称性，对于所有的v<w有w>v，且v=w时w=v；传递性，对于所有的v, w和x，如果v<=w且w<=x，则v<=x。

## 选择排序
最简单的排序算法：先找到数组中最小的那个元素，然后将它和数组第一个元素交换位置（如果第一个元素就是最小的，就和自己交换位置）。然后在剩下的元素中找到最小的位置，和第二个元素交换位置。如此往复，直到整个数组排序。*之所以叫这个算法为选择排序，因为它一直在选择数组中最小的那个元素。*

### 性能分析
对于有N个元素的数组，选择排序要进行N次交换和大约N**2/2次比较。选择排序的两个特点：
1. 无论输入数组的初始状态如何理想，该算法的运行时间都是相同的。这是该算法的缺点。
2. *概算法的交换操作次数是最少的，即交换的次数和数组的大小是线性关系*，其他的排序算法都不具备这个特点。

## 插入排序
>人们玩牌时，整理手里牌的方法是一张一张地将牌插入到手中 *已经有序的* 牌中的适当位置。

为了给新插入的元素腾位置，所有元素都要想右移动以为。

### 性能分析
与选择排序不同的是，插入排序所需的时间受输入数组初始状态的影响。对于随机排列的长度为N且 **主键不重复** 的数组，最坏情况下，即数组初始顺序刚好是逆序的，插入排序需要~N**2/2次交换，~N**2/2次比较。最好情况下，即初始数据刚好是有序的，插入排序需要0次交换，N-1次比较。平均情况下插入排序需要~N**2/4次交换，~N**2/4次比较。

### *什么是部分有序？*
如果数组中倒置的的数量小于数组大小的某个倍数，我们就说这个数组是部分有序的。本分有序数组的特点：
1. 数组中每个元素距离它的最终位置都不远。
2. 一个有序的大数组接一个小数组。
3. 数组中只有几个元素位置不正确。

###　*插入排序的性能优势*

插入排序对这样的数组非常有效，选择排序就糟透了。事实上，**当倒置的数量很少时，插入排序比其他排序算法更有效。** 插入排序处理部分有序的数组时，交换操作的次数和倒置的数量相同，比较操作的次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。

### 插入排序用途
插入排序对于部分有序的数组非常高效，也很适合小规模数组。部分排序的数组和小规模数组在实际应用中经常出现，插入排序经常是高级排序算法的中间过程。

### Further Reading
1. 提高插入排序速度，见习题2.1.25

## 数据可视化
### 排序算法的可视化
使用　*棒状图*　跟踪排序算法轨迹，能够是排序过程一目了然。

## 比较两种排序算法的快慢
### 比较两种算法的步骤
1. 实现并调试它们；
2. 分析它们的基本性质；
3. 对它们的相对性能做出猜想；
4. 用实验验证我们的猜想。

> 这些简介的步骤之下是大量的算法实现，调试分析和测试工作。每个程序员都知道只有经过长期的调试和改进才能得到这样的代码，每个数学家都知道正确分析的难度，每个科学家也都知道从提出猜想到设计并执行实验来验证它们是多么费心。只有研究那些最重要的算法的专家才会经理这个完整的研究过程，但每个使用算法的程序员都应该了解算法的性能特性背后的科学过程。

**对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别，两者之比应该是一个比较小的常数。**

### 基础排序算法的重要性
1. 它们帮助我们建立了一些基本的规则；
2. 它们展示一些性能基准；
3. 在某些特殊情况下它们也是很好的选择；
4. 它们开发更强大的排序算法的基石。

## 希尔排序
一种基于插入排序的快速的排序算法，*加速版插入排序*。插入排序慢是因为它只交换相邻的元素，也就是说新加入的元素只能一步一步地到达它的最终位置。

## 归并排序
### Top-down mergesort
It is one of the best-known examples of the utility of the *divide-and-conquer* paradigm for efficient 
algorithm design. An inductive proof that the algorithm sorts the array: if it sorts the two subarrays, 
it sorts the whole array, by merging together the subarrays.

The sort code simply provides an organized way to sequence the calls to the `merge()` method. This 
insight is useful.

#### mid index:
* `mid = lo + (hi - lo) / 2`
* `mid = length / 2 - 1`

#### 优化
1. **对小规模子数组使用插入排序**， 用不同的方法处理小规模问题能改进大多数递归算法的性能；
2. **测试数组是否已经有序**，添加一个判断条件，如果a[mid]小于等于a[mid+1]，我们就认为数组已经有序了并跳过调用`merge()`；
3. **不将元素复制到辅助数组**，需要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到输入数组。

#### 分治思想
递归实现的归并排序是算法设计中**分治思想**的典型应用。将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。

### 自底向上的归并排序
先归并微型数组，然后再成对归并得到的子数组，直到讲整个数组归并在一起。这种方法比标准的递归方法所需的代码量更少。
先两两归并，即把每个元素当成一个长度为一的数组，然后在四四归并，即把两个长度为二的数组归并......

这种归并排序比较适排序用链表组织的数据。

#### 排序算法的复杂度
*in progress*


## 快速排序
快速排序可能是应用最广泛的排序算法了，它实现简单，适用于各种不同的输入数据且在一般应用中比其他排序算法都要快得多。它的优点：
1. 它是原地排序，只需要一个很小的辅助栈；
2. 将长度为N的数组排序所需时间和NlogN成正比。

其他基础排序算法无法将这两个有点结合在一起。

每一次切分使得数组满足下面三个条件：
1. 对于每个j, a[j]已经排定；
2. a[lo]到a[j-1]中的所有元素**都不大于a[j]**；
3. a[j+1]到a[hi]中的所有元素**都不小于a[j]**。y


### 切分的一般策略
一般是随意的选取a[lo]作为切分元素，然后我们从数组的**左端**开始向右扫描，直到找到一个**大于等于**它的元素，再从数组右端向左扫描直到找到一个**小于等于**它的元素。
这两个元素显然没有排定，交换它们的位置。如此继续，我们就可以保证左指针i左侧的元素都不大于切分元素，右指针j右侧的元素都不小于切分元素。当两个指针相遇时，将切分元素
a[lo]和左子数组最右侧的元素a[j]交换然后返回j即可。

#### 切分是需要注意的细节，这些细节容易使实现出错或影响性能。
1. 原地切分，初级程序员可能会使用一个辅助数组完成切分；
2. 别越界，如果切分元素是数组中**最小或最大**的那个元素，我们就要小心别让扫描指针跑出数组的边界；
3. 保持随机性，打烂数组或随机选择一个切分元素；
4. 终止循环；
5. 处理切分元素值有重复的情况，左侧扫描最好实在遇到大于等于切分元素值的元素时停下，右侧扫描则是遇到小于等于切分元素值的元素时停下。尽管这样可能会不必要地将一些等值的元素交换，但在某些典型应用中，它能够避免算法的运行时间变为平方级别；
6. 终止递归，快速排序的一个常见错误就是不能保证讲切分元素放入正确的位置，从而导致程序在切分元素正好是子数组的最大或最小时陷入了无限的递归循环之中。

### 性能
归并和希尔排序比快速排序慢，因为它们在内循环中还要移动数据。快排的比较次数也比较少。

#### 改进
1. 在排序小数组时，切换的插入排序；
2. 三取样切分，使用子数组的一小部分元素的中位数来切分数组，这样等到的切分更好，但代价需要计算中位数；
3. 熵最优的排序，荷兰国旗问题。

*发明更快的排序算法好像是计算机科学界的“老鼠夹子”，而快速排序就是夹子里的那块奶酪。*

## 优先队列
一些应用场景不用对整个数组排序，只关心最大或最小的那个。在这种情况下，一个合适的数据结构应该支持两种操作：**删除最大元素和插入元素，**这种数据结构叫做**优先队列。**

* 队列，删除最老（最早入队）的元素；
* 栈，删除最新（最后入栈）的元素；
* 优先队列，删除最大的元素。

优先队列的一些重要的应用场景包括模拟系统，任务调度，数值计算。

## TODO:
1. 从标准输入读取数据
2. 数据可视化
3. 打印算法执行过程， 比如 *Top-down mergesort call trace*
